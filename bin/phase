#!/usr/bin/env python3
"""
IaL Phase CLI - Modular Infrastructure as Language Framework
Usage: phase <command> <module> [options]
"""

import sys
import os
import json
import yaml
import argparse
import subprocess
from pathlib import Path
from datetime import datetime

class PhaseFramework:
    def __init__(self):
        self.root_dir = Path(__file__).parent.parent
        self.modules_dir = self.root_dir / "modules"
        self.state_table = "mcp-provisioning-checklist"
        
    def load_module(self, module_name):
        """Load module configuration"""
        module_path = self.modules_dir / module_name / "module.yaml"
        if not module_path.exists():
            raise FileNotFoundError(f"Module {module_name} not found")
            
        with open(module_path) as f:
            return yaml.safe_load(f)
    
    def update_state(self, module_name, phase_name, status, details=None):
        """Update DynamoDB state"""
        item = {
            "Module": module_name,
            "Phase": phase_name,
            "Status": status,
            "Timestamp": datetime.now().isoformat(),
            "Details": details or {}
        }
        
        # Use AWS CLI to update DynamoDB
        cmd = [
            "aws", "dynamodb", "put-item",
            "--table-name", self.state_table,
            "--item", json.dumps({k: {"S": str(v)} for k, v in item.items()})
        ]
        subprocess.run(cmd, check=True)
    
    def get_state(self, module_name, phase_name=None):
        """Get current state from DynamoDB"""
        key = {"Module": {"S": module_name}}
        if phase_name:
            key["Phase"] = {"S": phase_name}
            
        cmd = [
            "aws", "dynamodb", "get-item",
            "--table-name", self.state_table,
            "--key", json.dumps(key)
        ]
        
        result = subprocess.run(cmd, capture_output=True, text=True)
        if result.returncode == 0:
            data = json.loads(result.stdout)
            return data.get("Item", {})
        return {}
    
    def deploy_module(self, module_name, dry_run=False, phase_filter=None):
        """Deploy a module"""
        print(f"üöÄ Deploying module: {module_name}")
        
        module_config = self.load_module(module_name)
        
        # Check dependencies
        for dep in module_config.get("metadata", {}).get("dependencies", []):
            dep_state = self.get_state(dep)
            if not dep_state or dep_state.get("Status", {}).get("S") != "COMPLETED":
                raise Exception(f"Dependency {dep} not satisfied")
        
        # Deploy phases
        phases = module_config.get("phases", [])
        if phase_filter:
            phases = [p for p in phases if p["name"] == phase_filter]
            
        for phase in phases:
            phase_name = phase["name"]
            print(f"  üìã Deploying phase: {phase_name}")
            
            if dry_run:
                print(f"    üîç DRY RUN: Would deploy {phase_name}")
                continue
                
            try:
                self.update_state(module_name, phase_name, "IN_PROGRESS")
                
                # Execute phase deployment
                phase_file = self.modules_dir / module_name / phase["file"]
                if phase_file.exists():
                    # Deploy using CloudFormation
                    stack_name = f"ial-{module_name}-{phase_name}"
                    cmd = [
                        "aws", "cloudformation", "deploy",
                        "--template-file", str(phase_file),
                        "--stack-name", stack_name,
                        "--capabilities", "CAPABILITY_IAM"
                    ]
                    
                    result = subprocess.run(cmd, capture_output=True, text=True)
                    if result.returncode == 0:
                        self.update_state(module_name, phase_name, "COMPLETED")
                        print(f"    ‚úÖ Phase {phase_name} completed")
                    else:
                        self.update_state(module_name, phase_name, "FAILED", {"error": result.stderr})
                        print(f"    ‚ùå Phase {phase_name} failed: {result.stderr}")
                        return False
                        
            except Exception as e:
                self.update_state(module_name, phase_name, "FAILED", {"error": str(e)})
                print(f"    ‚ùå Phase {phase_name} failed: {e}")
                return False
        
        self.update_state(module_name, "MODULE", "COMPLETED")
        print(f"‚úÖ Module {module_name} deployment completed")
        return True
    
    def validate_module(self, module_name):
        """Validate a module"""
        print(f"üîç Validating module: {module_name}")
        
        module_config = self.load_module(module_name)
        validation = module_config.get("validation", {})
        
        # Pre-deploy validation
        for check in validation.get("pre_deploy", []):
            print(f"  üîç {check['description']}")
            result = subprocess.run(check["check"], shell=True, capture_output=True)
            if result.returncode != 0:
                print(f"    ‚ùå Validation failed")
                return False
            print(f"    ‚úÖ Validation passed")
        
        # Post-deploy validation
        for check in validation.get("post_deploy", []):
            print(f"  üîç {check['description']}")
            result = subprocess.run(check["check"], shell=True, capture_output=True)
            if result.returncode != 0:
                print(f"    ‚ùå Validation failed")
                return False
            print(f"    ‚úÖ Validation passed")
        
        print(f"‚úÖ Module {module_name} validation completed")
        return True
    
    def rollback_module(self, module_name):
        """Rollback a module"""
        print(f"üîÑ Rolling back module: {module_name}")
        
        module_config = self.load_module(module_name)
        rollback_config = module_config.get("rollback", {})
        
        phases = rollback_config.get("phases", [])
        for phase_name in phases:
            print(f"  üîÑ Rolling back phase: {phase_name}")
            
            try:
                self.update_state(module_name, phase_name, "ROLLING_BACK")
                
                # Delete CloudFormation stack
                stack_name = f"ial-{module_name}-{phase_name}"
                cmd = [
                    "aws", "cloudformation", "delete-stack",
                    "--stack-name", stack_name
                ]
                
                result = subprocess.run(cmd, capture_output=True, text=True)
                if result.returncode == 0:
                    self.update_state(module_name, phase_name, "ROLLED_BACK")
                    print(f"    ‚úÖ Phase {phase_name} rolled back")
                else:
                    print(f"    ‚ö†Ô∏è Phase {phase_name} rollback warning: {result.stderr}")
                    
            except Exception as e:
                print(f"    ‚ùå Phase {phase_name} rollback failed: {e}")
        
        self.update_state(module_name, "MODULE", "ROLLED_BACK")
        print(f"‚úÖ Module {module_name} rollback completed")
    
    def list_modules(self):
        """List available modules"""
        print("üì¶ Available modules:")
        
        for module_dir in self.modules_dir.iterdir():
            if module_dir.is_dir() and (module_dir / "module.yaml").exists():
                try:
                    config = self.load_module(module_dir.name)
                    status = self.get_state(module_dir.name, "MODULE")
                    status_str = status.get("Status", {}).get("S", "NOT_DEPLOYED")
                    
                    print(f"  üìã {module_dir.name}")
                    print(f"      Description: {config['module']['description']}")
                    print(f"      Status: {status_str}")
                    print(f"      Phases: {len(config.get('phases', []))}")
                    print()
                except Exception as e:
                    print(f"  ‚ùå {module_dir.name} (error loading: {e})")

def main():
    parser = argparse.ArgumentParser(description="IaL Phase Framework CLI")
    parser.add_argument("command", choices=["deploy", "validate", "rollback", "list", "status"])
    parser.add_argument("module", nargs="?", help="Module name")
    parser.add_argument("--dry-run", action="store_true", help="Dry run mode")
    parser.add_argument("--phase", help="Specific phase to execute")
    
    args = parser.parse_args()
    
    framework = PhaseFramework()
    
    try:
        if args.command == "list":
            framework.list_modules()
        elif args.command == "deploy":
            if not args.module:
                print("‚ùå Module name required for deploy command")
                sys.exit(1)
            framework.deploy_module(args.module, args.dry_run, args.phase)
        elif args.command == "validate":
            if not args.module:
                print("‚ùå Module name required for validate command")
                sys.exit(1)
            framework.validate_module(args.module)
        elif args.command == "rollback":
            if not args.module:
                print("‚ùå Module name required for rollback command")
                sys.exit(1)
            framework.rollback_module(args.module)
        elif args.command == "status":
            if args.module:
                state = framework.get_state(args.module, "MODULE")
                print(f"Module {args.module} status: {state.get('Status', {}).get('S', 'NOT_DEPLOYED')}")
            else:
                framework.list_modules()
                
    except Exception as e:
        print(f"‚ùå Error: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
