#!/usr/bin/env python3
"""
GitHub Integration for IAL
Handles automatic commit and push to user's GitHub repository
"""

import os
import json
import subprocess
from typing import Dict, List
from datetime import datetime

class GitHubIntegration:
    def __init__(self):
        self.config = self.load_config()
        self.repo_path = "/home/ial"  # Assuming IAL is run from repo directory
    
    def load_config(self) -> Dict:
        """Load IAL configuration"""
        try:
            with open('/etc/ial/parameters.env', 'r') as f:
                config = {}
                for line in f:
                    if '=' in line and not line.startswith('#'):
                        key, value = line.strip().split('=', 1)
                        config[key] = value
                return config
        except Exception as e:
            print(f"âš ï¸ Could not load config: {e}")
            return {}
    
    def execute_infrastructure_deployment(self, templates: Dict, intent: Dict) -> Dict:
        """Execute infrastructure deployment via GitHub"""
        
        try:
            # 1. Save templates to correct phase directories
            saved_files = self.save_templates_to_phases(templates)
            
            if not saved_files:
                return {
                    'response': "âŒ No templates were generated",
                    'status': 'error'
                }
            
            # 2. Git commit
            commit_msg = self.generate_commit_message(intent)
            commit_result = self.git_commit(saved_files, commit_msg)
            
            if commit_result['status'] != 'success':
                return {
                    'response': f"âŒ Git commit failed: {commit_result['message']}",
                    'status': 'error'
                }
            
            # 3. Git push
            push_result = self.git_push()
            
            if push_result['status'] == 'success':
                return {
                    'response': f"âœ… Infrastructure changes pushed to GitHub!\nðŸ”— {self.config.get('GITHUB_REPOSITORY')}\nðŸš€ GitHub Actions will deploy automatically in a few moments.",
                    'status': 'success',
                    'github_url': f"{self.config.get('GITHUB_REPOSITORY')}/commits",
                    'deployment_status': 'triggered',
                    'files_changed': len(saved_files)
                }
            else:
                return {
                    'response': f"âŒ Failed to push to GitHub: {push_result['message']}",
                    'status': 'error'
                }
                
        except Exception as e:
            return {
                'response': f"âŒ Deployment error: {str(e)}",
                'status': 'error'
            }
    
    def save_templates_to_phases(self, templates: Dict) -> List[str]:
        """Save generated templates to phase directories - CORRIGIDO: serializaÃ§Ã£o"""
        saved_files = []
        
        for file_path, content in templates.items():
            try:
                # Ensure directory exists
                full_path = os.path.join(self.repo_path, file_path)
                os.makedirs(os.path.dirname(full_path), exist_ok=True)
                
                # CORREÃ‡ÃƒO: Serializar content se nÃ£o for string
                if isinstance(content, (list, dict)):
                    import json
                    content_str = json.dumps(content, indent=2)
                elif not isinstance(content, str):
                    content_str = str(content)
                else:
                    content_str = content
                
                # Write template content
                with open(full_path, 'w') as f:
                    f.write(content_str)
                
                saved_files.append(file_path)
                print(f"ðŸ“ Saved: {file_path}")
                
            except Exception as e:
                print(f"âŒ Error saving {file_path}: {e}")
        
        return saved_files
    
    def generate_commit_message(self, intent: Dict) -> str:
        """Generate meaningful commit message based on intent"""
        action = intent.get('action', 'update')
        domains = intent.get('domains', ['infrastructure'])
        
        domain_str = ', '.join(domains)
        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M')
        
        messages = {
            'create': f"feat: Create {domain_str} infrastructure",
            'update': f"feat: Update {domain_str} infrastructure", 
            'delete': f"feat: Remove {domain_str} infrastructure"
        }
        
        base_msg = messages.get(action, f"feat: {action.title()} {domain_str} infrastructure")
        
        return f"{base_msg}\n\nGenerated by IAL on {timestamp}\nOriginal command: {intent.get('original_input', 'N/A')}"
    
    def git_commit(self, files: List[str], message: str) -> Dict:
        """Commit files to git"""
        try:
            # Add files
            for file_path in files:
                result = subprocess.run(
                    ['git', 'add', file_path],
                    cwd=self.repo_path,
                    capture_output=True,
                    text=True
                )
                if result.returncode != 0:
                    return {
                        'status': 'error',
                        'message': f"Git add failed: {result.stderr}"
                    }
            
            # Commit
            result = subprocess.run(
                ['git', 'commit', '-m', message],
                cwd=self.repo_path,
                capture_output=True,
                text=True
            )
            
            if result.returncode == 0:
                return {
                    'status': 'success',
                    'message': 'Files committed successfully',
                    'output': result.stdout.strip()
                }
            else:
                return {
                    'status': 'error',
                    'message': f"Git commit failed: {result.stderr}"
                }
                
        except Exception as e:
            return {
                'status': 'error',
                'message': f"Git commit error: {str(e)}"
            }
    
    def git_push(self) -> Dict:
        """Push commits to remote repository"""
        try:
            # Configure git with GitHub token for authentication
            repo_url = self.config.get('GITHUB_REPOSITORY', '')
            github_token = self.config.get('GITHUB_TOKEN', '')
            
            if github_token and repo_url:
                # Use token for authentication
                auth_url = repo_url.replace('https://', f'https://{github_token}@')
                
                # Set remote URL with token
                subprocess.run(
                    ['git', 'remote', 'set-url', 'origin', auth_url],
                    cwd=self.repo_path,
                    capture_output=True
                )
            
            # Push to remote
            result = subprocess.run(
                ['git', 'push', 'origin', 'main'],
                cwd=self.repo_path,
                capture_output=True,
                text=True
            )
            
            if result.returncode == 0:
                return {
                    'status': 'success',
                    'message': 'Successfully pushed to GitHub',
                    'output': result.stdout.strip() or result.stderr.strip()
                }
            else:
                return {
                    'status': 'error',
                    'message': f"Git push failed: {result.stderr}"
                }
                
        except Exception as e:
            return {
                'status': 'error',
                'message': f"Git push error: {str(e)}"
            }
