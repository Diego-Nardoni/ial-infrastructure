#!/usr/bin/env python3
"""
GitHub Integration for IAL
Handles automatic commit and push to user's GitHub repository
"""

import os
import json
import subprocess
from typing import Dict, List
from datetime import datetime

class GitHubIntegration:
    def __init__(self):
        self.config = self.load_config()
        self.repo_path = "/home/ial"  # Assuming IAL is run from repo directory
    
    def load_config(self) -> Dict:
        """Load IAL configuration"""
        try:
            with open('/etc/ial/parameters.env', 'r') as f:
                config = {}
                for line in f:
                    if '=' in line and not line.startswith('#'):
                        key, value = line.strip().split('=', 1)
                        config[key] = value
                return config
        except Exception as e:
            print(f"âš ï¸ Could not load config: {e}")
            return {}
    
    def execute_full_gitops_flow(self, templates: Dict, intent: Dict) -> Dict:
        """Execute complete GitOps flow: branch â†’ commit â†’ push â†’ PR â†’ trigger workflow"""
        
        try:
            # 1. Save templates to phase directories
            saved_files = self.save_templates_to_phases(templates)
            
            if not saved_files:
                return {
                    'status': 'error',
                    'message': 'No templates were generated'
                }
            
            # 2. Create feature branch
            timestamp = datetime.now().strftime('%Y%m%d-%H%M%S')
            branch_name = f"ial-{intent.get('action', 'update')}-{timestamp}"
            
            branch_result = self.create_feature_branch(branch_name)
            if branch_result['status'] != 'success':
                return branch_result
            
            # 3. Commit changes
            commit_message = self.generate_commit_message(intent)
            commit_result = self.git_commit(saved_files, commit_message)
            
            if commit_result['status'] != 'success':
                return commit_result
            
            # 4. Push to remote
            push_result = self.git_push_branch(branch_name)
            if push_result['status'] != 'success':
                return push_result
            
            # 5. Create Pull Request
            pr_title = f"IAL: {intent.get('action', 'Update').title()} {', '.join(intent.get('domains', ['infrastructure']))}"
            pr_body = f"""
## IAL Infrastructure Changes

**Action:** {intent.get('action', 'update')}
**Domains:** {', '.join(intent.get('domains', ['infrastructure']))}
**Original Command:** `{intent.get('original_input', 'N/A')}`

### Files Changed:
{chr(10).join(f'- {file}' for file in saved_files)}

### Generated by IAL
- Timestamp: {datetime.now().isoformat()}
- Branch: {branch_name}

**Review and merge to deploy infrastructure changes.**
"""
            
            pr_result = self.create_pull_request(branch_name, pr_title, pr_body)
            if pr_result['status'] != 'success':
                return pr_result
            
            # 6. Trigger validation workflow
            workflow_inputs = {
                'pr_number': str(pr_result['pr_number']),
                'branch': branch_name,
                'action': intent.get('action', 'update')
            }
            
            workflow_result = self.trigger_workflow('ial-pipeline.yml', workflow_inputs)
            
            return {
                'status': 'success',
                'message': 'Full GitOps flow completed successfully',
                'pr_url': pr_result['pr_url'],
                'pr_number': pr_result['pr_number'],
                'branch': branch_name,
                'files_changed': saved_files,
                'workflow_triggered': workflow_result['status'] == 'success'
            }
            
        except Exception as e:
            return {
                'status': 'error',
                'message': f'GitOps flow error: {str(e)}'
            }
    
    def git_push_branch(self, branch_name: str) -> Dict:
        """Push specific branch to remote"""
        try:
            # Configure git with GitHub token for authentication
            repo_url = self.config.get('GITHUB_REPOSITORY', '')
            github_token = self.config.get('GITHUB_TOKEN', '')
            
            if github_token and repo_url:
                # Use token for authentication
                if not repo_url.startswith('https://'):
                    repo_url = f"https://github.com/{repo_url}"
                auth_url = repo_url.replace('https://', f'https://{github_token}@')
                
                # Set remote URL with token
                subprocess.run(
                    ['git', 'remote', 'set-url', 'origin', auth_url],
                    cwd=self.repo_path,
                    capture_output=True
                )
            
            # Push branch to remote
            result = subprocess.run(
                ['git', 'push', 'origin', branch_name],
                cwd=self.repo_path,
                capture_output=True,
                text=True
            )
            
            if result.returncode == 0:
                return {
                    'status': 'success',
                    'message': f'Branch {branch_name} pushed successfully'
                }
            else:
                return {
                    'status': 'error',
                    'message': f'Git push failed: {result.stderr}'
                }
                
        except Exception as e:
            return {
                'status': 'error',
                'message': f'Git push error: {str(e)}'
            }

    def execute_infrastructure_deployment(self, templates: Dict, intent: Dict) -> Dict:
        """Execute infrastructure deployment via GitHub"""
        
        try:
            # Check if this is a list/query intent - don't generate templates
            if intent.get('intent') == 'list_information':
                return {
                    'response': "ðŸ“‹ Para listar as fases do IAL, consulte o repositÃ³rio GitHub diretamente. Use o MCP GitHub para acessar /phases/ e mostrar as fases existentes.",
                    'status': 'no_templates_generated',
                    'action': 'list_only'
                }
            
            # 1. Save templates to correct phase directories
            saved_files = self.save_templates_to_phases(templates)
            
            if not saved_files:
                return {
                    'response': "âŒ No templates were generated",
                    'status': 'error'
                }
            
            # 2. Git commit
            commit_msg = self.generate_commit_message(intent)
            commit_result = self.git_commit(saved_files, commit_msg)
            
            if commit_result['status'] != 'success':
                return {
                    'response': f"âŒ Git commit failed: {commit_result['message']}",
                    'status': 'error'
                }
            
            # 3. Git push
            push_result = self.git_push()
            
            if push_result['status'] == 'success':
                return {
                    'response': f"âœ… Infrastructure changes pushed to GitHub!\nðŸ”— {self.config.get('GITHUB_REPOSITORY')}\nðŸš€ GitHub Actions will deploy automatically in a few moments.",
                    'status': 'success',
                    'github_url': f"{self.config.get('GITHUB_REPOSITORY')}/commits",
                    'deployment_status': 'triggered',
                    'files_changed': len(saved_files)
                }
            else:
                return {
                    'response': f"âŒ Failed to push to GitHub: {push_result['message']}",
                    'status': 'error'
                }
                
        except Exception as e:
            return {
                'response': f"âŒ Deployment error: {str(e)}",
                'status': 'error'
            }
    
    def save_templates_to_phases(self, templates: Dict) -> List[str]:
        """Save generated templates to phase directories - CORRIGIDO: serializaÃ§Ã£o"""
        saved_files = []
        
        for file_path, content in templates.items():
            try:
                # Ensure directory exists
                full_path = os.path.join(self.repo_path, file_path)
                os.makedirs(os.path.dirname(full_path), exist_ok=True)
                
                # CORREÃ‡ÃƒO: Serializar content se nÃ£o for string
                if isinstance(content, (list, dict)):
                    import json
                    content_str = json.dumps(content, indent=2)
                elif not isinstance(content, str):
                    content_str = str(content)
                else:
                    content_str = content
                
                # Write template content
                with open(full_path, 'w') as f:
                    f.write(content_str)
                
                saved_files.append(file_path)
                print(f"ðŸ“ Saved: {file_path}")
                
            except Exception as e:
                print(f"âŒ Error saving {file_path}: {e}")
        
        return saved_files
    
    def generate_commit_message(self, intent: Dict) -> str:
        """Generate meaningful commit message based on intent"""
        action = intent.get('action', 'update')
        domains = intent.get('domains', ['infrastructure'])
        
        domain_str = ', '.join(domains)
        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M')
        
        messages = {
            'create': f"feat: Create {domain_str} infrastructure",
            'update': f"feat: Update {domain_str} infrastructure", 
            'delete': f"feat: Remove {domain_str} infrastructure"
        }
        
        base_msg = messages.get(action, f"feat: {action.title()} {domain_str} infrastructure")
        
        return f"{base_msg}\n\nGenerated by IAL on {timestamp}\nOriginal command: {intent.get('original_input', 'N/A')}"
    
    def git_commit(self, files: List[str], message: str) -> Dict:
        """Commit files to git"""
        try:
            # Add files
            for file_path in files:
                result = subprocess.run(
                    ['git', 'add', file_path],
                    cwd=self.repo_path,
                    capture_output=True,
                    text=True
                )
                if result.returncode != 0:
                    return {
                        'status': 'error',
                        'message': f"Git add failed: {result.stderr}"
                    }
            
            # Commit
            result = subprocess.run(
                ['git', 'commit', '-m', message],
                cwd=self.repo_path,
                capture_output=True,
                text=True
            )
            
            if result.returncode == 0:
                return {
                    'status': 'success',
                    'message': 'Files committed successfully',
                    'output': result.stdout.strip()
                }
            else:
                return {
                    'status': 'error',
                    'message': f"Git commit failed: {result.stderr}"
                }
                
        except Exception as e:
            return {
                'status': 'error',
                'message': f"Git commit error: {str(e)}"
            }
    
    def create_pull_request(self, branch_name: str, title: str, body: str) -> Dict:
        """Create Pull Request via GitHub API"""
        try:
            import requests
            
            github_token = self.config.get('GITHUB_TOKEN', '')
            github_repo = self.config.get('GITHUB_REPOSITORY', '')
            
            if not github_token or not github_repo:
                return {
                    'status': 'error',
                    'message': 'GitHub token or repository not configured'
                }
            
            # GitHub API endpoint
            url = f"https://api.github.com/repos/{github_repo}/pulls"
            
            headers = {
                'Authorization': f'token {github_token}',
                'Accept': 'application/vnd.github.v3+json',
                'Content-Type': 'application/json'
            }
            
            data = {
                'title': title,
                'body': body,
                'head': branch_name,
                'base': 'main'
            }
            
            response = requests.post(url, headers=headers, json=data)
            
            if response.status_code == 201:
                pr_data = response.json()
                return {
                    'status': 'success',
                    'pr_url': pr_data['html_url'],
                    'pr_number': pr_data['number'],
                    'message': f'Pull Request created: #{pr_data["number"]}'
                }
            else:
                return {
                    'status': 'error',
                    'message': f'GitHub API error: {response.status_code} - {response.text}'
                }
                
        except Exception as e:
            return {
                'status': 'error',
                'message': f'Pull Request creation error: {str(e)}'
            }
    
    def create_feature_branch(self, branch_name: str) -> Dict:
        """Create and checkout feature branch"""
        try:
            # Create and checkout new branch
            result = subprocess.run(
                ['git', 'checkout', '-b', branch_name],
                cwd=self.repo_path,
                capture_output=True,
                text=True
            )
            
            if result.returncode == 0:
                return {
                    'status': 'success',
                    'message': f'Branch {branch_name} created and checked out'
                }
            else:
                return {
                    'status': 'error',
                    'message': f'Branch creation failed: {result.stderr}'
                }
                
        except Exception as e:
            return {
                'status': 'error',
                'message': f'Branch creation error: {str(e)}'
            }
    
    def trigger_workflow(self, workflow_name: str, inputs: Dict = None) -> Dict:
        """Trigger GitHub Actions workflow via API"""
        try:
            import requests
            
            github_token = self.config.get('GITHUB_TOKEN', '')
            github_repo = self.config.get('GITHUB_REPOSITORY', '')
            
            if not github_token or not github_repo:
                return {
                    'status': 'error',
                    'message': 'GitHub token or repository not configured'
                }
            
            # GitHub API endpoint for workflow dispatch
            url = f"https://api.github.com/repos/{github_repo}/actions/workflows/{workflow_name}/dispatches"
            
            headers = {
                'Authorization': f'token {github_token}',
                'Accept': 'application/vnd.github.v3+json',
                'Content-Type': 'application/json'
            }
            
            data = {
                'ref': 'main',
                'inputs': inputs or {}
            }
            
            response = requests.post(url, headers=headers, json=data)
            
            if response.status_code == 204:
                return {
                    'status': 'success',
                    'message': f'Workflow {workflow_name} triggered successfully'
                }
            else:
                return {
                    'status': 'error',
                    'message': f'Workflow trigger failed: {response.status_code} - {response.text}'
                }
                
        except Exception as e:
            return {
                'status': 'error',
                'message': f'Workflow trigger error: {str(e)}'
            }

    def git_push(self) -> Dict:
        """Push commits to remote repository"""
        try:
            # Configure git with GitHub token for authentication
            repo_url = self.config.get('GITHUB_REPOSITORY', '')
            github_token = self.config.get('GITHUB_TOKEN', '')
            
            if github_token and repo_url:
                # Use token for authentication
                auth_url = repo_url.replace('https://', f'https://{github_token}@')
                
                # Set remote URL with token
                subprocess.run(
                    ['git', 'remote', 'set-url', 'origin', auth_url],
                    cwd=self.repo_path,
                    capture_output=True
                )
            
            # Push to remote
            result = subprocess.run(
                ['git', 'push', 'origin', 'main'],
                cwd=self.repo_path,
                capture_output=True,
                text=True
            )
            
            if result.returncode == 0:
                return {
                    'status': 'success',
                    'message': 'Successfully pushed to GitHub',
                    'output': result.stdout.strip() or result.stderr.strip()
                }
            else:
                return {
                    'status': 'error',
                    'message': f"Git push failed: {result.stderr}"
                }
                
        except Exception as e:
            return {
                'status': 'error',
                'message': f"Git push error: {str(e)}"
            }
